{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///PostRPC.Client.min.js","webpack:///webpack/bootstrap 83f56868056b070ead09","webpack:///./src/client.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","jsonrpc","timeoutCode","timeoutMessage","timeoutData","PostRPCClient","origin","_this","_name","_origin","_id","_queue","_subscribed","_logging","setInterval","timeoutHandler","event","callback","log","_this2","window","addEventListener","messageHandler","_this3","removeEventListener","method","params","error","code","message","data","timeout","arguments","undefined","JSON","stringify","push","sent","Date","now","parent","postMessage","request","nextID","timeoutResponse","splice","response","messages","subscribe","enabled","color","console","group","groupEnd","get","default"],"mappings":"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","file":"PostRPC.Client.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Client\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Client\"] = factory();\n\telse\n\t\troot[\"PostRPC\"] = root[\"PostRPC\"] || {}, root[\"PostRPC\"][\"Client\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Client\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Client\"] = factory();\n\telse\n\t\troot[\"PostRPC\"] = root[\"PostRPC\"] || {}, root[\"PostRPC\"][\"Client\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * PostRPC Client\n\t *\n\t * Implements JSON RPC v2 protocol over window.postMessage transport\n\t * providing sandboxed iFrames a secure/restricted communication\n\t * mechanism.\n\t *\n\t * In addition to calling registered RCP's, the client can subscribe\n\t * to published notifications from the server.\n\t *\n\t * Usage:\n\t *\n\t * Load PostRPC.Client library into child iFrame window and create a\n\t * client instance and then start the client:\n\t *\n\t *\n\t *\t\tvar client = new window.PostRPC.Client('http://localhost:5001');\n\t *\t\tclient.start();\n\t *\n\t * Notifications can be subscribed to any time afterwards as:\n\t *\n\t *\n\t *\t\tclient.subscribe('changed', function(response) {\n\t *\t\t\tdisplay(null, response);\n\t *\t\t});\n\t *\n\t * Registered server RPC's can be called any time afterwards as:\n\t *\n\t *\t\t\tclient.call('add', {a: 2, b: 2}, function(response) {\n\t *\t\t\t\tdisplay(response);\n\t *\t\t\t});\n\t *\n\t */\n\t\n\tvar jsonrpc = '2.0';\n\t\n\tvar timeoutCode = -32001,\n\t    timeoutMessage = 'Timeout',\n\t    timeoutData = 'The server didn\\'t respond to request within timeframe allowed.';\n\t\n\tvar PostRPCClient = function () {\n\t\tfunction PostRPCClient(origin) {\n\t\t\tvar _this = this;\n\t\n\t\t\t_classCallCheck(this, PostRPCClient);\n\t\n\t\t\tthis._name = 'PostRPC.Client';\n\t\t\tthis._origin = origin;\n\t\t\tthis._id = 1;\n\t\t\tthis._queue = [];\n\t\t\tthis._subscribed = {};\n\t\t\tthis._logging = false;\n\t\t\tsetInterval(function () {\n\t\t\t\treturn _this.timeoutHandler();\n\t\t\t}, 250);\n\t\t}\n\t\n\t\t/**\n\t  * Get client class name\n\t  * @return {string} class name\n\t  */\n\t\n\t\n\t\t_createClass(PostRPCClient, [{\n\t\t\tkey: 'subscribe',\n\t\n\t\n\t\t\t/**\n\t   * Subscribe to notification\n\t   * @param {String} event\n\t   * @param {Function} callback function to notify\n\t   * @return {Undefined}\n\t  */\n\t\t\tvalue: function subscribe(event, callback) {\n\t\t\t\tthis.log(['subscribe', 'event: ' + event, 'callback: function() {}']);\n\t\t\t\tthis._subscribed[event] = {\n\t\t\t\t\tcallback: callback\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Unsubscribe from notification\n\t   * @param {String} event\n\t   * @return {Undefined}\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: 'unsubscribe',\n\t\t\tvalue: function unsubscribe(event) {\n\t\t\t\tdelete this._subscribed[event];\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Increment to the next id\n\t   * @return {Number} id\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'nextID',\n\t\t\tvalue: function nextID() {\n\t\t\t\treturn this._id++;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Start the client (add postMessage event listener)\n\t   * @return {Undefined}\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: 'start',\n\t\t\tvalue: function start() {\n\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\twindow.addEventListener('message', function (event) {\n\t\t\t\t\treturn _this2.messageHandler(event);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Stop the client (remove postMessage event listener)\n\t   * @return {Undefined}\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: 'stop',\n\t\t\tvalue: function stop() {\n\t\t\t\tvar _this3 = this;\n\t\n\t\t\t\twindow.removeEventListener('message', function (event) {\n\t\t\t\t\treturn _this3.messageHandler(event);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t/**\n\t   * JSON-RPC v2 request\n\t   * @return {Object} response\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: 'request',\n\t\t\tvalue: function request(method, params, id) {\n\t\t\t\treturn {\n\t\t\t\t\tjsonrpc: jsonrpc,\n\t\t\t\t\tmethod: method,\n\t\t\t\t\tparams: params,\n\t\t\t\t\tid: id\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t/**\n\t   * JSON-RPC v2+ timeout response\n\t   * @return {Object} response\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: 'timeoutResponse',\n\t\t\tvalue: function timeoutResponse(id) {\n\t\t\t\treturn {\n\t\t\t\t\tjsonrpc: jsonrpc,\n\t\t\t\t\terror: {\n\t\t\t\t\t\tcode: timeoutCode,\n\t\t\t\t\t\tmessage: timeoutMessage,\n\t\t\t\t\t\tdata: timeoutData\n\t\t\t\t\t},\n\t\t\t\t\tid: id\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Call a registered RPC\n\t   * @param {String} method\n\t   * @param {Object|Array} params\n\t   * @param {Function} callback to return response\n\t   * @param {Number} timeout in MS to await response\n\t   * @return {Undefined}\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: 'call',\n\t\t\tvalue: function call(method, params, callback) {\n\t\t\t\tvar timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5000;\n\t\n\t\t\t\tthis.log(['call', 'method: ' + method, 'params: ' + JSON.stringify(params), 'callback: function() {}', 'timeout: ' + timeout]);\n\t\t\t\tthis._queue.push({\n\t\t\t\t\tmethod: method,\n\t\t\t\t\tparams: params,\n\t\t\t\t\tid: this.id,\n\t\t\t\t\tsent: Date.now(),\n\t\t\t\t\ttimeout: timeout,\n\t\t\t\t\tcallback: callback\n\t\t\t\t});\n\t\t\t\tparent.postMessage(this.request(method, params, this.id), this._origin);\n\t\t\t\tthis.nextID();\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Handle RPC timeouts (server does not respond\n\t   * within a given amount of time)\n\t   * @return {Undefined}\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: 'timeoutHandler',\n\t\t\tvalue: function timeoutHandler() {\n\t\t\t\tvar now = Date.now();\n\t\n\t\t\t\tfor (var i = this._queue.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar call = this._queue[i];\n\t\n\t\t\t\t\t// Expired?\n\t\t\t\t\tif (now - call.sent > call.timeout) {\n\t\t\t\t\t\tthis.log(['call expired, id: ' + call.id, 'timeout response', 'called, call callback']);\n\t\t\t\t\t\tcall.callback(this.timeoutResponse(call.id));\n\t\t\t\t\t\tthis._queue.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Handle postMessage events for child iFrame window\n\t   * @param {Object} event\n\t   * @return {Undefined}\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: 'messageHandler',\n\t\t\tvalue: function messageHandler(event) {\n\t\t\t\t// this.log([\n\t\t\t\t// \t'event origin' + event.origin,\n\t\t\t\t// \t'event data' + event.data,\n\t\t\t\t// \t'event source' + event.source,\n\t\t\t\t// \t'this origin' + this._origin\n\t\t\t\t// ]);\n\t\n\t\t\t\tif (event.origin === this._origin) {\n\t\t\t\t\tvar response = event.data;\n\t\t\t\t\tvar messages = ['response: ' + JSON.stringify(response)];\n\t\n\t\t\t\t\tif (response && response.id) {\n\t\t\t\t\t\t// Call\n\t\t\t\t\t\tmessages.push('call response');\n\t\n\t\t\t\t\t\tfor (var i = this._queue.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tvar call = this._queue[i];\n\t\n\t\t\t\t\t\t\t// Match to queue\n\t\t\t\t\t\t\tif (response.id === call.id) {\n\t\t\t\t\t\t\t\tmessages.push('called, call callback');\n\t\t\t\t\t\t\t\tcall.callback(response);\n\t\t\t\t\t\t\t\tthis._queue.splice(i, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (response && response.event) {\n\t\t\t\t\t\t// Event\n\t\t\t\t\t\tmessages.push('event response');\n\t\n\t\t\t\t\t\tif (response.event in this._subscribed) {\n\t\t\t\t\t\t\tmessages.push('subscribed, call callback');\n\t\t\t\t\t\t\tvar subscribe = this._subscribed[response.event];\n\t\t\t\t\t\t\tsubscribe.callback(response);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.log(messages);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Enable/Disable console logging\n\t   * @param {String} event\n\t   * @param {Function} callback function to notify\n\t   * @return {Undefined}\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: 'logging',\n\t\t\tvalue: function logging(enabled) {\n\t\t\t\tthis._logging = enabled;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Log messages to console\n\t   * @param {Array[String]} messages\n\t   * @param {String} color\n\t   * @return {Undefined}\n\t  */\n\t\n\t\t}, {\n\t\t\tkey: 'log',\n\t\t\tvalue: function log(messages) {\n\t\t\t\tvar color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'green';\n\t\n\t\t\t\tif (this._logging) {\n\t\t\t\t\tconsole.group(this._name);\n\t\t\t\t\tfor (var i = 0; i < messages.length; i++) {\n\t\t\t\t\t\tconsole.log('%c%s', 'color:' + color, messages[i]);\n\t\t\t\t\t}\n\t\t\t\t\tconsole.groupEnd();\n\t\t\t\t}\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'name',\n\t\t\tget: function get() {\n\t\t\t\treturn this._name;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Get origin uri expected from server\n\t   * @return {string} class name\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'origin',\n\t\t\tget: function get() {\n\t\t\t\treturn this._origin;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Get current id\n\t   * @return {Number} id\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'id',\n\t\t\tget: function get() {\n\t\t\t\treturn this._id;\n\t\t\t}\n\t\n\t\t\t/**\n\t   * Get list of subscribed notifications's\n\t   * @return {Array[Object]} notifications\n\t   */\n\t\n\t\t}, {\n\t\t\tkey: 'subscribed',\n\t\t\tget: function get() {\n\t\t\t\treturn this._subscribed;\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn PostRPCClient;\n\t}();\n\t\n\texports.default = PostRPCClient;\n\tmodule.exports = exports['default'];\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// PostRPC.Client.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 83f56868056b070ead09","/**\n * PostRPC Client\n *\n * Implements JSON RPC v2 protocol over window.postMessage transport\n * providing sandboxed iFrames a secure/restricted communication\n * mechanism.\n *\n * In addition to calling registered RCP's, the client can subscribe\n * to published notifications from the server.\n *\n * Usage:\n *\n * Load PostRPC.Client library into child iFrame window and create a\n * client instance and then start the client:\n *\n *\n *\t\tvar client = new window.PostRPC.Client('http://localhost:5001');\n *\t\tclient.start();\n *\n * Notifications can be subscribed to any time afterwards as:\n *\n *\n *\t\tclient.subscribe('changed', function(response) {\n *\t\t\tdisplay(null, response);\n *\t\t});\n *\n * Registered server RPC's can be called any time afterwards as:\n *\n *\t\t\tclient.call('add', {a: 2, b: 2}, function(response) {\n *\t\t\t\tdisplay(response);\n *\t\t\t});\n *\n */\n\nconst jsonrpc = '2.0';\n\nconst timeoutCode = -32001,\n\t  timeoutMessage = 'Timeout',\n\t  timeoutData = 'The server didn\\'t respond to request within timeframe allowed.';\n\nexport default class PostRPCClient {\n\n\tconstructor(origin) {\n\t\tthis._name = 'PostRPC.Client';\n\t\tthis._origin = origin;\n\t\tthis._id = 1;\n\t\tthis._queue = [];\n\t\tthis._subscribed = {};\n\t\tthis._logging = false;\n\t\tsetInterval(() => this.timeoutHandler(), 250);\n\t}\n\n\t/**\n\t * Get client class name\n\t * @return {string} class name\n\t */\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * Get origin uri expected from server\n\t * @return {string} class name\n\t */\n\tget origin() {\n\t\treturn this._origin;\n\t}\n\n\t/**\n\t * Get current id\n\t * @return {Number} id\n\t */\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\t/**\n\t * Get list of subscribed notifications's\n\t * @return {Array[Object]} notifications\n\t */\n\tget subscribed() {\n\t\treturn this._subscribed;\n\t}\n\n\t/**\n\t * Subscribe to notification\n\t * @param {String} event\n\t * @param {Function} callback function to notify\n\t * @return {Undefined}\n\t*/\n\tsubscribe(event, callback) {\n\t\tthis.log([\n\t\t\t'subscribe',\n\t\t\t'event: ' + event,\n\t\t\t'callback: function() {}'\n\t\t]);\n\t\tthis._subscribed[event] = {\n\t\t\tcallback: callback\n\t\t};\n\t}\n\n\t/**\n\t * Unsubscribe from notification\n\t * @param {String} event\n\t * @return {Undefined}\n\t*/\n\tunsubscribe(event) {\n\t\tdelete this._subscribed[event];\n\t}\n\n\t/**\n\t * Increment to the next id\n\t * @return {Number} id\n\t */\n\tnextID() {\n\t\treturn this._id++;\n\t}\n\n\t/**\n\t * Start the client (add postMessage event listener)\n\t * @return {Undefined}\n\t*/\n\tstart() {\n\t\twindow.addEventListener('message', (event) => this.messageHandler(event));\n\t}\n\n\t/**\n\t * Stop the client (remove postMessage event listener)\n\t * @return {Undefined}\n\t*/\n\tstop() {\n\t\twindow.removeEventListener('message', (event) => this.messageHandler(event));\n\t}\n\n\t/**\n\t * JSON-RPC v2 request\n\t * @return {Object} response\n\t*/\n\trequest(method, params, id) {\n\t\treturn {\n\t\t\tjsonrpc: jsonrpc,\n\t\t\tmethod: method,\n\t\t\tparams: params,\n\t\t\tid: id\n\t\t};\n\t}\n\n\t/**\n\t * JSON-RPC v2+ timeout response\n\t * @return {Object} response\n\t*/\n\ttimeoutResponse(id) {\n\t\treturn {\n\t\t\tjsonrpc: jsonrpc,\n\t\t\terror: {\n\t\t\t\tcode: timeoutCode,\n\t\t\t\tmessage: timeoutMessage,\n\t\t\t\tdata: timeoutData\n\t\t\t},\n\t\t\tid: id\n\t\t};\n\t}\n\n\t/**\n\t * Call a registered RPC\n\t * @param {String} method\n\t * @param {Object|Array} params\n\t * @param {Function} callback to return response\n\t * @param {Number} timeout in MS to await response\n\t * @return {Undefined}\n\t*/\n\tcall(method, params, callback, timeout = 5000) {\n\t\tthis.log([\n\t\t\t'call',\n\t\t\t'method: ' + method,\n\t\t\t'params: ' + JSON.stringify(params),\n\t\t\t'callback: function() {}',\n\t\t\t'timeout: ' + timeout\n\t\t]);\n\t\tthis._queue.push({\n\t\t\tmethod: method,\n\t\t\tparams: params,\n\t\t\tid: this.id,\n\t\t\tsent: Date.now(),\n\t\t\ttimeout: timeout,\n\t\t\tcallback: callback\n\t\t});\n\t\tparent.postMessage(this.request(method, params, this.id), this._origin);\n\t\tthis.nextID();\n\t}\n\n\t/**\n\t * Handle RPC timeouts (server does not respond\n\t * within a given amount of time)\n\t * @return {Undefined}\n\t*/\n\ttimeoutHandler() {\n\t\tvar now = Date.now();\n\n\t\tfor (var i = this._queue.length - 1; i >= 0; i--) {\n\t\t\tvar call = this._queue[i];\n\n\t\t\t// Expired?\n\t\t\tif ((now - call.sent) > call.timeout) {\n\t\t\t\tthis.log([\n\t\t\t\t\t'call expired, id: ' + call.id,\n\t\t\t\t\t'timeout response',\n\t\t\t\t\t'called, call callback'\n\t\t\t\t]);\n\t\t\t\tcall.callback(this.timeoutResponse(call.id));\n\t\t\t\tthis._queue.splice(i, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Handle postMessage events for child iFrame window\n\t * @param {Object} event\n\t * @return {Undefined}\n\t*/\n\tmessageHandler(event) {\n\t\t// this.log([\n\t\t// \t'event origin' + event.origin,\n\t\t// \t'event data' + event.data,\n\t\t// \t'event source' + event.source,\n\t\t// \t'this origin' + this._origin\n\t\t// ]);\n\n        if (event.origin === this._origin) {\n\t\t\tvar response = event.data;\n\t\t\tvar messages = ['response: ' + JSON.stringify(response)];\n\n\t\t\tif (response && response.id) {\t// Call\n\t\t\t\tmessages.push('call response');\n\n\t\t\t\tfor (var i = this._queue.length - 1; i >= 0; i--) {\n\t\t\t\t\tvar call = this._queue[i];\n\n\t\t\t\t\t// Match to queue\n\t\t\t\t\tif (response.id === call.id) {\n\t\t\t\t\t\tmessages.push('called, call callback');\n\t\t\t\t\t\tcall.callback(response);\n\t\t\t\t\t\tthis._queue.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else if (response && response.event) {\t// Event\n\t\t\t\tmessages.push('event response');\n\n\t\t\t\tif (response.event in this._subscribed) {\n\t\t\t\t\tmessages.push('subscribed, call callback');\n\t\t\t\t\tvar subscribe = this._subscribed[response.event];\n\t\t\t\t\tsubscribe.callback(response);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tthis.log(messages);\n        }\n    }\n\n\t/**\n\t * Enable/Disable console logging\n\t * @param {String} event\n\t * @param {Function} callback function to notify\n\t * @return {Undefined}\n\t*/\n\tlogging(enabled) {\n\t\tthis._logging = enabled;\n\t}\n\n\t/**\n\t * Log messages to console\n\t * @param {Array[String]} messages\n\t * @param {String} color\n\t * @return {Undefined}\n\t*/\n\tlog(messages, color = 'green') {\n\t\tif (this._logging) {\n\t\t\tconsole.group(this._name);\n\t\t\tfor (var i = 0; i < messages.length; i++) {\n\t\t\t\tconsole.log('%c%s', 'color:' + color, messages[i]);\n\t\t\t}\n\t\t\tconsole.groupEnd();\n\t\t}\n\t}\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/client.js"],"sourceRoot":""}